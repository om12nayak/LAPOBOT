# Designed by:-
# THIS PYTHON FILE IS A PART OF ALGO FAMILY.
# THIS HAS A SINGLE CLASS ValidateTokens() with a SINGLE FUNCTION AS get_validtokens()
# THIS FUNCTION GENERATES THE USEFUL TOKENS from the tokens that come from the algo_token.py that is 
# to be sent to the get_output() of algo_responsegenerator file for further manipulation

# For eg if token that are generated in the algo_token are - [need, laptop, dell, and, price, 45000], then this 
# function will return the new token list as -[dell, and, 45000] which are very useful and this process 
# reduces the task of algo_responsegenerator which will now work on only 3 words instead of 6 words and 
# produces the response much faster. It actually does a great task because if the responseGenerator
# works on both the lists, the output will be same but here it reduces the pain of responseGenerator.

#Basically here first we check according to the priority and then according to the flags so that the 
#intents with LESS and SAME priority are discarded by using the flags which are unique to each type of element.

#For reading the json data from the json file
import json
#To send the new_tokens list to get_output() for further manipulation
from algo_responsegenerator import ResponseGenerator

#Reduces the number of tokens which are really useful
class ValidateTokens():
    #It takes 5 arguments:
    #token - list of the words that are generated by algo_token.py
    #flag_variable_set - list containg the flags of the words
    #priority_variable_set - list containing the priority of the words
    #username - name of the user
    #date - time of the message
    def get_validtokens(token, flag_variable_set, priority_variable_set,username,date):
        with open('Filelist.json', 'r') as f:
                dic_file_list = json.load(f)

        #open the laptop configuration file which is a json file
        #and it contain all the configuration of various laptops
        with open(dic_file_list['filelist']['config_file'], 'r') as f:
                dic_laptop_config = json.load(f)

        #open the valid-token file which is a json file
        #and it contain all the valid tokens with its
        #priority and flag value respectively
        with open(dic_file_list['filelist']['valid_tokens_file'], 'r') as f:
                dic_validtoken = json.load(f)

        #open the invalid-token file which is a json file
        #and it contain all the invalid token with its
        #priority and flag value respectively
        with open(dic_file_list['filelist']['invalid_tokens_file'], 'r') as f:
                dic_invalidtoken = json.load(f)

        #Declaring 3 lists thats will hold the new words, their respective flags and 
        #their respective priority according to the storing sequence in the 'new_tokens_variable_set' list
        new_tokens_variable_set = []
        new_flag_variable_set = []
        new_priority_variable_set_variable_set = []

        #If any joiner is there it is being checked by comparing the priority of the 
        #joiner in the json file and the that of the priority_varibale_set, 
        #if found then the new lists are appended
        if (dic_validtoken['tokens']['priority']['joiner'] in priority_variable_set):
            new_flag_variable_set.append(
                flag_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['joiner'])])
            new_tokens_variable_set.append(
                token[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['joiner'])])
            new_priority_variable_set_variable_set.append(
                priority_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['joiner'])])
            
            #If any purpose,price,brand is there it is being checked by comparing the priority of the 
            #purpose in the json file and the that of the priority_varibale_set.
            #Here we are checking the priority of the purpose as purpose, brand, and 
            #price have same priority and there is no need to check for the othe two.
            #Here as the joiner is found then we know we have two intents so the next priority 
            #which is less than joiner is checked and the useful intents are found out.
            if (dic_validtoken['tokens']['priority']['purpose'] in priority_variable_set):
                #After we are sure that we have either a purpose,brand and price we now look 
                #for each element out of it and for that we take the help of flag list which is unique to each element.

                #At first we check for the purpose intents,if we find any then all the 3 new lists are appended.
                if (dic_validtoken['tokens']['flag']['purpose'] in flag_variable_set):
                    new_flag_variable_set.append(
                        flag_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['purpose'])])
                    new_tokens_variable_set.append(
                        token[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['purpose'])])
                    new_priority_variable_set_variable_set.append(
                        priority_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['purpose'])])

                #Then we check for the brand intents,if we find any then all the 3 new lists are appended.
                if (dic_validtoken['tokens']['flag']['brandname'] in flag_variable_set):
                    new_flag_variable_set.append(
                        flag_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['brandname'])])
                    new_tokens_variable_set.append(
                        token[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['brandname'])])
                    new_priority_variable_set_variable_set.append(
                        priority_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['brandname'])])
                
                #Then we check for the price intents,if we find any then all the 3 new lists are appended.
                if (dic_validtoken['tokens']['flag']['pricenumber'] in flag_variable_set):
                    new_flag_variable_set.append(
                        flag_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])
                    new_tokens_variable_set.append(
                        token[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])
                    new_priority_variable_set_variable_set.append(
                        priority_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])
                    
                    #Here we also check the value token because in price we are dealing with tokens of 
                    # price like less,great,cost,etc but if the user enter only the number then it has to be
                    # checked with the value token, so here we are also checking with the valuetokens and
                    # if any found then the 3 new lists are appended 
                    if(dic_validtoken['tokens']['flag']['valuetoken'] in flag_variable_set):
                            # print( token[flag_variable_set.index(
                            #         dic_validtoken['tokens']['flag']['valuetoken'])])
                        if(token[flag_variable_set.index(
                                     dic_validtoken['tokens']['flag']['valuetoken'])] in dic_validtoken['tokens']['valid']['oppovalue']):
                            new_flag_variable_set.append(
                                flag_variable_set[flag_variable_set.index(
                                    dic_validtoken['tokens']['flag']['valuetoken'])])
                            new_tokens_variable_set.append(
                                token[flag_variable_set.index(
                                    dic_validtoken['tokens']['flag']['valuetoken'])])
                            new_priority_variable_set_variable_set.append(
                                priority_variable_set[flag_variable_set.index(
                                    dic_validtoken['tokens']['flag']['valuetoken'])])

        #Now after the joiner ,if joiner is not found then the purpose 
        #intents are checked and if found then the new lists are appended.
        elif (dic_validtoken['tokens']['flag']['purpose'] in flag_variable_set):
            new_flag_variable_set.append(
                flag_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['purpose'])])
            new_tokens_variable_set.append(
                token[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['purpose'])])
            new_priority_variable_set_variable_set.append(
                priority_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['purpose'])])
        
        #Now after the purpose ,if purpose is not found then the brand 
        #intents are checked and if found then the new lists are appended.
        elif (dic_validtoken['tokens']['flag']['brandname'] in flag_variable_set):
            new_flag_variable_set.append(
                flag_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['brandname'])])
            new_tokens_variable_set.append(
                token[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['brandname'])])
            new_priority_variable_set_variable_set.append(
                priority_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['brandname'])])

            #After joiner now we are handling single entity so if we give "DELL 1001", 
            #then as single entity and as there is a gap between the DELL and 1001 then 
            #it will take only the dell as intent and it will show us the dell laptops 
            #but here we want the specs of 'DELL1001' so here we are also checking 
            #whether the number is 4 digits ,if it is so then we append it as a brand 
            #dell and also as price of 4 digits and in the responsegenerator we tackle 
            #the situation inside the brand ckecking that whether the next intent is 
            #a 4 digit price if it is so then the price is converted to a model 
            #number and is send as a brand model.
            if(dic_validtoken['tokens']['flag']['pricenumber'] in flag_variable_set):
                if(len(str(token[flag_variable_set.index(dic_validtoken['tokens']['flag']['pricenumber'])]))==4):
                    new_flag_variable_set.append(
                        flag_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])
                    new_tokens_variable_set.append(
                        token[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])
                    new_priority_variable_set_variable_set.append(
                        priority_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['pricenumber'])])

        #Now after the brand ,if brand is not found then the price 
        #intents are checked and if found then the new lists are appended.
        elif (dic_validtoken['tokens']['flag']['pricenumber'] in flag_variable_set):
            new_flag_variable_set.append(
                flag_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['pricenumber'])])
            new_tokens_variable_set.append(
                token[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['pricenumber'])])
            new_priority_variable_set_variable_set.append(
                priority_variable_set[flag_variable_set.index(
                    dic_validtoken['tokens']['flag']['pricenumber'])])

            #Let instead of price intents, the number is only given 
            #as input at that time the value token are searched and 
            #if there then the lists are appended.
            if(dic_validtoken['tokens']['flag']['valuetoken'] in flag_variable_set):
                if(token[flag_variable_set.index(
                                     dic_validtoken['tokens']['flag']['valuetoken'])] in dic_validtoken['tokens']['valid']['oppovalue']):
                    new_flag_variable_set.append(
                        flag_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['valuetoken'])])
                    new_tokens_variable_set.append(
                        token[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['valuetoken'])])
                    new_priority_variable_set_variable_set.append(
                        priority_variable_set[flag_variable_set.index(
                            dic_validtoken['tokens']['flag']['valuetoken'])])

        #After all the checking, let from the previous file the tokens 
        #that are coming are already useful so at that time no condition 
        #will match and there we have to assign the older lists to the 
        #newer lists so that it could be sent to the response 
        #generator for further manipulation.  
        if (new_tokens_variable_set == []):
            new_tokens_variable_set = token
            new_priority_variable_set_variable_set = priority_variable_set
            new_flag_variable_set = flag_variable_set
        # print(new_tokens_variable_set, "==>newtokens")
        # print(new_priority_variable_set_variable_set, "==>new priority_variable_set")
        # print(new_flag_variable_set, "==>new flag")

        #Here after we get the new lists, that along with the 
        #username and time of the message is then sent as argument to the 
        #get_output() function of the responseGenerator for further 
        #manipulation and the result is then returned back to the algo_token.py. 
        return ResponseGenerator.get_output(new_tokens_variable_set, 
            new_flag_variable_set, new_priority_variable_set_variable_set,username,date)




